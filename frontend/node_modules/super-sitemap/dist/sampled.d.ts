import dirTree from 'directory-tree';
/**
 * Given the URL to this project's sitemap, _which must have been generated by
 * Super Sitemap for this to work as designed_, returns an array containing:
 * 1. the URL of every static route, and
 * 2. one URL for every parameterized route.
 *
 * ```js
 * // Example result:
 * [ 'http://localhost:5173/', 'http://localhost:5173/about', 'http://localhost:5173/blog', 'http://localhost:5173/blog/hello-world', 'http://localhost:5173/blog/tag/red' ]
 * ```
 *
 * @public
 * @param sitemapUrl - E.g. http://localhost:5173/sitemap.xml
 * @returns Array of paths, one for each route; grouped by static, then dynamic; sub-sorted alphabetically.
 *
 * @remarks
 * - This is intended as a utility to gather unique URLs for SEO analysis,
 *   functional tests for public routes, etc.
 * - As a utility, the design favors ease of use for the developer over runtime
 *   performance, and consequently consumes `/sitemap.xml` directly, to avoid
 *   the developer needing to recreate and maintain a duplicate sitemap config,
 *   param values, exclusion rules, etc.
 * - LIMITATIONS:
 *   1. The result does not include `additionalPaths` from the sitemap config
 *      b/c it's impossible to identify those by pattern using only the result.
 *   2. This does not distinguish between routes that differ only due to a
 *      pattern matcher–e.g.`/foo/[foo]` and `/foo/[foo=integer]` will evaluated
 *      as `/foo/[foo]` and one sample URL will be returned.
 */
export declare function sampledUrls(sitemapUrl: string): Promise<string[]>;
/**
 * Given the URL to this project's sitemap, _which must have been generated by
 * Super Sitemap for this to work as designed_, returns an array containing:
 * 1. the path of every static route, and
 * 2. one path for every parameterized route.
 *
 * ```js
 * // Example result:
 * [ '/', '/about', '/blog', '/blog/hello-world', '/blog/tag/red' ]
 * ```
 *
 * @public
 * @param sitemapUrl - E.g. http://localhost:5173/sitemap.xml
 * @returns Array of paths, one for each route; grouped by static, then dynamic; sub-sorted alphabetically.
 *
 * @remarks
 * - This is intended as a utility to gather unique paths for SEO analysis,
 *   functional tests for public routes, etc.
 * - As a utility, the design favors ease of use for the developer over runtime
 *   performance, and consequently consumes `/sitemap.xml` directly, to avoid
 *   the developer needing to recreate and maintain a duplicate sitemap config,
 *   param values, exclusion rules, etc.
 * - LIMITATIONS:
 *   1. The result does not include `additionalPaths` from the sitemap config
 *      b/c it's impossible to identify those by pattern using only the result.
 *   2. This does not distinguish between routes that differ only due to a
 *      pattern matcher–e.g.`/foo/[foo]` and `/foo/[foo=integer]` will evaluated
 *      as `/foo/[foo]` and one sample path will be returned.
 */
export declare function sampledPaths(sitemapUrl: string): Promise<string[]>;
/**
 * Given the body of this site's sitemap.xml, returns an array containing:
 * 1. the URL of every static (non-parameterized) route, and
 * 2. one URL for every parameterized route.
 *
 * @private
 * @param sitemapXml - The XML string of the sitemap to analyze. This must have
 *                     been created by Super Sitemap to work as designed.
 * @returns Array of URLs, sorted alphabetically
 */
export declare function _sampledUrls(sitemapXml: string): Promise<string[]>;
/**
 * Given the body of this site's sitemap.xml, returns an array containing:
 * 1. the path of every static (non-parameterized) route, and
 * 2. one path for every parameterized route.
 *
 * @private
 * @param sitemapXml - The XML string of the sitemap to analyze. This must have
 *                     been created by Super Sitemap to work as designed.
 * @returns Array of paths, sorted alphabetically
 */
export declare function _sampledPaths(sitemapXml: string): Promise<string[]>;
/**
 * Given a set of strings, return the first matching string for every regex
 * within a set of regex patterns. It is possible and allowed for no match to be
 * found for a given regex.
 *
 * @private
 * @param regexPatterns - Set of regex patterns to search for.
 * @param haystack - Array of strings to search within.
 * @returns Set of strings where each is the first match found for a pattern.
 *
 * @example
 * ```ts
 * const patterns = new Set(["a.*", "b.*"]);
 * const haystack = ["apple", "banana", "cherry"];
 * const result = findFirstMatches(patterns, haystack); // Set { 'apple', 'banana' }
 * ```
 */
export declare function findFirstMatches(regexPatterns: Set<string>, haystack: string[]): Set<string>;
/**
 * Extracts the paths from a dirTree response and returns an array of strings
 * representing full disk paths to each route and directory.
 * - This needs to be filtered to remove items that do not end in `+page.svelte`
 *   in order to represent routes; we do that outside of this function given
 *   this is recursive.
 *
 * @param obj - The dirTree response object. https://www.npmjs.com/package/directory-tree
 * @param paths - Array of existing paths to append to (leave unspecified; used
 * for recursion)
 * @returns An array of strings representing disk paths to each route.
 */
export declare function extractPaths(obj: dirTree.DirectoryTree, paths?: string[]): string[];
